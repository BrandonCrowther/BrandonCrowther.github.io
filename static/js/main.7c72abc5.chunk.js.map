{"version":3,"sources":["NeuralPreloadedInterface.js","NeuralTrainingInterface.js","Game.js","GameBoard.js","App.js","serviceWorker.js","index.js","config.js","Objects.js"],"names":["require","Head","Snake","Tail","BOARD_SIZE","Cheese","tf","NeuralPreloadedInterface","model","this","head","cheese","score","distX","x","y","getLength","distY","distSouth","Math","abs","params","next","checkCollision","predict","tidy","_","tensor","tensor2d","length","flatten","arraySync","formatMove","move","processed","indexOf","max","NeuralTrainingInterface","newModel","inputs","scores","sequential","layers","dense","units","activation","inputShape","compile","optimizer","loss","metrics","categoricalCrossentropy","board","distNorth","distEast","distWest","canMoveUp","canMoveRight","canMoveDown","canMoveLeft","push","testScore","save","inputsAsTensor","scoreAsTensor","fit","epochs","dispose","Game","input","Array","map","e","fill","ticks","floor","random","createNewCheese","states","dist","distance","redraw","getMove","oldNode","gameOver","checkCheese","deleteLast","newDist","potX","potY","snakePos","getPositions","find","forEach","coords","sqrt","pow","GameBoard","props","sleep","ms","Promise","resolve","setTimeout","increaseSpeed","setState","speed","state","decreaseSpeed","toggleMode","trainingMode","isLoaded","tfModel","modelInterface","gameLoop","game","done","tick","train","topScore","run","trainingInterface","fitReplay","colorMap","0","1","2","3","onClick","className","f","Spinner","animation","role","style","width","height","React","Component","App","href","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message","module","exports","undefined","node","arr"],"mappings":"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","file":"static/js/main.7c72abc5.chunk.js","sourcesContent":["\n\nconst {Snake, Tail, Head, Cheese} = require('./Objects')\nconst {BOARD_SIZE} = require('./config')\nconst tf = require('@tensorflow/tfjs')\n\n\nclass NeuralPreloadedInterface{\n    constructor(model, tf){\n        this.model = model\n        this.tf = tf\n    }\n\n    getMove(head, cheese, score) {\n        const posX = head.x / BOARD_SIZE\n        const posY = head.y / BOARD_SIZE\n        const snakeLen = head.getLength() / (BOARD_SIZE * BOARD_SIZE)\n\n        const distX = (cheese.x - head.x) / BOARD_SIZE\n        const distY = (cheese.y - head.y) / BOARD_SIZE\n\n        // distance in each direction\n        const distSouth = distY >= 0 ? Math.abs(distY) : 0\n        const distNorth = distY <= 0 ? Math.abs(distY) : 0\n        const distEast =  distX >= 0 ? Math.abs(distX) : 0\n        const distWest =  distX <= 0 ? Math.abs(distX) : 0\n\n        // hack to check collisions because I didnt think far enough ahead\n        const canMoveUp =     new Head(head.x, head.y - 1, head.next).checkCollision() ? 0 : 1\n        const canMoveRight =  new Head(head.x + 1, head.y, head.next).checkCollision() ? 0 : 1\n        const canMoveDown =   new Head(head.x, head.y + 1, head.next).checkCollision() ? 0 : 1\n        const canMoveLeft =   new Head(head.x - 1, head.y, head.next).checkCollision() ? 0 : 1\n\n        const params = [\n            // posX,\n            // posY,\n            // snakeLen,\n            distNorth,\n            distEast,\n            distSouth,\n            distWest,\n            canMoveUp, \n            canMoveRight, \n            canMoveDown, \n            canMoveLeft\n        ]\n\n        \n        const predict = tf.tidy(_ => {\n            const tensor =  tf.tensor2d(params, [1, params.length])\n            return this.model.predict(tensor).flatten().arraySync()\n        })\n\n        const move = this.formatMove(predict)\n        return move\n    }\n\n    formatMove(move) {\n        // console.log(move)\n        const processed = move.indexOf(Math.max(...move));\n        if(processed == 0) //N\n            return [0, -1]\n        if(processed == 1) //E\n            return [1, 0]\n        if(processed == 2) //S\n            return [0, 1]\n        if(processed == 3) //W\n            return [-1, 0]\n    }\n\n}\n\n\nexport {NeuralPreloadedInterface}","const tf = require('@tensorflow/tfjs')\nconst {Snake, Tail, Head, Cheese} = require('./Objects')\nconst {BOARD_SIZE} = require('./config')\n\nclass NeuralTrainingInterface{\n    constructor(){\n        this.newModel()\n\n        this.inputs = []\n        this.scores = []\n    }\n\n    newModel(){      \n        tf.tidy(() => {\n            this.model = tf.sequential({\n                layers: [\n                    tf.layers.dense({units: 4, activation: \"softmax\", inputShape: [8]})\n                ]\n            })\n            this.model.compile({\n                optimizer: 'adam',\n                loss: tf.metrics.categoricalCrossentropy,\n            })\n        })\n    }\n\n    \n    getMove(head, cheese, score, board) {\n\n\n        const posX = head.x / BOARD_SIZE\n        const posY = head.y / BOARD_SIZE\n        const snakeLen = head.getLength() / (BOARD_SIZE * BOARD_SIZE)\n\n        const distX = (cheese.x - head.x) / BOARD_SIZE\n        const distY = (cheese.y - head.y) / BOARD_SIZE\n\n        // distance in each direction\n        const distSouth = distY >= 0 ? Math.abs(distY) : 0\n        const distNorth = distY <= 0 ? Math.abs(distY) : 0\n        const distEast =  distX >= 0 ? Math.abs(distX) : 0\n        const distWest =  distX <= 0 ? Math.abs(distX) : 0\n\n        // hack to check collisions because I didnt think far enough ahead\n        const canMoveUp =     new Head(head.x, head.y - 1, head.next).checkCollision() ? 0 : 1\n        const canMoveRight =  new Head(head.x + 1, head.y, head.next).checkCollision() ? 0 : 1\n        const canMoveDown =   new Head(head.x, head.y + 1, head.next).checkCollision() ? 0 : 1\n        const canMoveLeft =   new Head(head.x - 1, head.y, head.next).checkCollision() ? 0 : 1\n\n        const params = [\n            // posX,\n            // posY,\n            // snakeLen,\n            distNorth,\n            distEast,\n            distSouth,\n            distWest,\n            canMoveUp, \n            canMoveRight, \n            canMoveDown, \n            canMoveLeft\n        ]\n\n        \n        const predict = tf.tidy(_ => {\n            const tensor =  tf.tensor2d(params, [1, params.length])\n            return this.model.predict(tensor).flatten().arraySync()\n        })\n        \n\n        this.inputs.push(params)\n\n        // for any valid moves apply a minimum training weight as 0.1\n        // for any invalid moves, set to 0 because DO NOT WANT\n        var testScore = [0,0,0,0]\n        if(canMoveUp > 0)\n            testScore[0] = 0.1 + (distNorth / 2) / 1.1\n        if(canMoveRight > 0)\n            testScore[1] = 0.1 + (distEast / 2) / 1.1\n        if(canMoveDown > 0)\n            testScore[2] = 0.1 + (distSouth / 2) / 1.1\n        if(canMoveLeft > 0)\n            testScore[3] = 0.1 + (distWest / 2) / 1.1\n\n        this.scores.push(testScore)\n\n        const move = this.formatMove(predict)\n        return move\n    }\n\n    formatMove(move) {\n        const processed = move.indexOf(Math.max(...move));\n        if(processed == 0) //N\n            return [0, -1]\n        if(processed == 1) //E\n            return [1, 0]\n        if(processed == 2) //S\n            return [0, 1]\n        if(processed == 3) //W\n            return [-1, 0]\n    }\n\n    async save(score){\n        await this.model.save('downloads://\" + ' + score)\n    }\n\n    async fitReplay(){\n        const [inputsAsTensor, scoreAsTensor] = tf.tidy(_ => [\n            tf.tensor2d(this.inputs, [this.inputs.length, this.inputs[0].length]),\n            tf.tensor2d(this.scores, [this.scores.length, this.scores[0].length])\n        ])\n        \n        await this.model.fit(inputsAsTensor, scoreAsTensor, {epochs: 100})\n\n        // reset replay\n        this.scores = []\n        this.inputs = []\n\n        // probably redundant disposal\n        scoreAsTensor.dispose()\n        inputsAsTensor.dispose()\n    }\n\n}\n\nexport {NeuralTrainingInterface}","const {Snake, Tail, Head, Cheese} = require('./Objects')\nconst {BOARD_SIZE} = require('./config')\n\nconst EMPTY = 0;\nconst HEAD = 1;\nconst TAIL = 2;\nconst CHEESE = 3;\n\n\nclass Game{\n    constructor(input){\n        this.input = input;\n        this.board = [...Array(BOARD_SIZE)].map(e => Array(BOARD_SIZE).fill(EMPTY));\n        this.score = 0\n        this.ticks = 0\n        this.head = new Head(\n            Math.floor((BOARD_SIZE / 4) + (Math.random() * (BOARD_SIZE / 4))), \n            Math.floor((BOARD_SIZE / 4) + (Math.random() * (BOARD_SIZE / 4)))\n        )\n        this.head.next = new Tail(this.head.x -1, this.head.y)\n        this.cheese = this.createNewCheese()\n\n        this.states = []\n\n        this.dist = this.distance()\n        \n\n        this.redraw()\n    }\n\n\n    tick() {\n        let move = this.input.getMove(this.head, this.cheese, this.score, this.board)\n        let oldNode = new Tail(this.head.x, this.head.y)\n\n        if(this.head.next){\n            oldNode.next = this.head.next\n            this.head.next = oldNode\n        }\n        else{\n            this.head.next = oldNode;\n        }\n        \n        this.head.x += move[0]\n        this.head.y += move[1]\n\n        let gameOver = this.head.checkCollision()\n\n        let cheeseFound = this.checkCheese()\n\n        if(cheeseFound){\n            this.cheese = this.createNewCheese()\n            this.score += 10\n            this.ticks = 0\n        }\n        else\n            this.head.deleteLast()\n\n        this.ticks++\n        // this.score += 1\n\n\n        if(this.ticks == BOARD_SIZE * BOARD_SIZE){\n            gameOver = true\n        }\n\n        if(gameOver){\n            // this.score -= 10;\n        }\n        if(!gameOver){\n            this.redraw()\n\n            const newDist = this.distance()\n            if(this.dist > newDist){\n                this.score += 1\n            }\n            else\n                this.score -= 1\n\n            this.dist = newDist\n        }\n\n        return gameOver;\n    }\n\n\n    checkCheese(){\n        return (this.head.x == this.cheese.x \n            && this.head.y == this.cheese.y)\n    }\n\n    createNewCheese(){\n        let potX = Math.floor(Math.random() * BOARD_SIZE)\n        let potY = Math.floor(Math.random() * BOARD_SIZE)\n\n        const snakePos = this.head.getPositions()\n\n        while(snakePos.find(x => x[0] == potX && x[1] == potY)){\n            potX = Math.floor(Math.random() * BOARD_SIZE)\n            potY = Math.floor(Math.random() * BOARD_SIZE)\n        }\n\n        return new Cheese(potX, potY);\n    }\n\n\n    redraw(){\n        this.board = [...Array(BOARD_SIZE)].map(e => Array(BOARD_SIZE).fill(EMPTY));\n        let positions = this.head.getPositions()\n\n        positions.forEach((coords) => {\n            this.board[coords[1]][coords[0]] = TAIL;\n        })\n        \n        this.board[this.head.y][this.head.x] = HEAD;\n        this.board[this.cheese.y][this.cheese.x] = CHEESE;\n\n        this.states.push(this.board)\n        \n    }\n\n    distance(){\n        return Math.sqrt(Math.abs(\n            Math.pow((this.head.x - this.cheese.x), 2) +\n            Math.pow((this.head.y - this.cheese.y), 2)\n        ))\n    }\n}\n\n\nexport { Game }","import React from 'react';\nimport Spinner from 'react-bootstrap/Spinner';\nimport './GameBoard.css';\nimport * as tf from '@tensorflow/tfjs';\nimport { NeuralPreloadedInterface } from './NeuralPreloadedInterface'\nimport { NeuralTrainingInterface}  from './NeuralTrainingInterface'\nimport { Game } from './Game'\n\nclass GameBoard extends React.Component{\n\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n            isLoaded: false,\n            board: [[]],\n            speed: 25,\n            trainingMode: false\n        }\n\t}\n\t\n    sleep = ms => new Promise(resolve => setTimeout(resolve, ms))\n\n\tasync componentDidMount() {\n        await tf.ready()\n\n        const tfModel = await tf.loadLayersModel('model/model.json');\n        const modelInterface = new NeuralPreloadedInterface(tfModel)\n        \n\t\tthis.setState({\n            isLoaded: true,\n            modelInterface: modelInterface\n        }, this.gameLoop)\n    }\n\n    async gameLoop(){\n        while(!this.state.trainingMode){\n            let game = new Game(this.state.modelInterface)\n\n            let done = false;\n            while(!done){\n                done = game.tick();\n                this.setState({board: game.board})\n                await this.sleep(this.state.speed)\n            }\n    \n            await this.sleep(1000)\n        }\n        this.train()\n    }\n\n    async train(){\n        var topScore = 0;\n        var run = 1;\n        const trainingInterface = new NeuralTrainingInterface();\n        while(this.state.trainingMode){\n            run++;\n            var game = new Game(trainingInterface)\n            var done = false;\n            while(!done){\n                done = game.tick();\n                await this.sleep(this.state.speed)\n                this.setState({board: game.board, run: run})\n            }\n    \n            await trainingInterface.fitReplay()\n\n            if(game.score > topScore){\n                topScore = game.score;\n                // await trainingInterface.save('downloads://\" + ' + topScore)\n                this.setState({topScore: topScore})\n            }\n        }\n        this.gameLoop()\n    }\n\n    increaseSpeed = _ =>{\n        this.setState({speed: Math.max(this.state.speed - 5, 0)})\n    }\n\n    decreaseSpeed = _ =>{\n        this.setState({speed: this.state.speed + 5})\n    }\n\n    toggleMode = _ => {\n        this.setState({trainingMode: !this.state.trainingMode})\n    }\n\n\t\n\trender() {\n        const {trainingMode, isLoaded, board, run} = this.state;\n        \n        const fatSpinnerStyle = {width: 4+\"rem\", height: 4+\"rem\"}\n\n        const colorMap = {\n            0: \"gray\",\n            1: \"red\",\n            2: \"black\",\n            3: \"yellow\"\n        }\n\n\t\tif(!isLoaded){\n\t\t\treturn (\n\t\t\t\t<Spinner animation=\"border\" role=\"status\" style={fatSpinnerStyle}>\n                    <span className=\"sr-only\">Loading...</span>\n                </Spinner>\n\t\t\t)\n\t\t}\n\t\treturn (\n            <div>\n                <div>\n                    <button onClick={this.toggleMode}>Toggle Mode</button> {trainingMode ? \"Training Mode\" : \"Pre-trained Mode\"}\n                </div>\n                <div>\n                    {/* Run: {run} */}\n                </div>\n                <div>\n                    <button onClick={this.decreaseSpeed}>-</button>\n                    Game Speed\n                    <button onClick={this.increaseSpeed}>+</button>\n                </div>\n                <div className=\"board\">\n                    {board.map(e => {\n                        return e.map(f => \n                            <div className={\"block \" + colorMap[f]}></div>)\n                    })}\n                </div>\n            </div>\n\t\t);\n\t}\n\t\t\t\n}\nexport default GameBoard;\n\t\t","import React from 'react';\nimport './App.css';\nimport GameBoard from './GameBoard'\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>Snake Neural Network</h1>\n      <p>\n        <span>By Brandon Crowther</span> \n        <strong>&nbsp;&nbsp;|&nbsp;&nbsp;</strong> \n        <a href=\"https://github.com/BrandonCrowther/SnakeNN\">Github</a>\n        <strong>&nbsp;&nbsp;|&nbsp;&nbsp;</strong> \n        <a href=\"mailto:bcrowthe11@gmail.com\">bcrowthe11@gmail.com</a>\n      </p>\n      <div className=\"game\">\n        <div>\n          <GameBoard></GameBoard>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = {\n    BOARD_SIZE: 10\n}","\n\nconst {BOARD_SIZE} = require('./config')\n\nclass Snake{\n    constructor(x, y, next = undefined){\n        this.x = x;\n        this.y = y;\n        this.next = next;\n    }\n\n\n    deleteLast () {\n        if(this.next){\n            if(this.next.next){\n                return this.next.deleteLast()\n            }\n            else{\n                this.next = null;\n                return true;\n            }\n        }\n    }\n\n}\n\nclass Tail extends Snake{}\n\nclass Head extends Snake{\n    checkCollision () {\n        let node = this.next;\n\n        while(node != null){\n            if(this.x == node.x && this.y == node.y)\n                return true;\n            node = node.next;\n        }\n\n        if(this.x == BOARD_SIZE || this.x < 0)\n            return true;\n        if(this.y == BOARD_SIZE || this.y < 0)\n            return true;\n\n        return false;\n    }\n    \n    getPositions () {\n        let arr = [[this.x, this.y]]\n        let node = this.next;\n        while(node != null){\n            arr.push([node.x, node.y])\n            node = node.next;\n        }\n        return arr;\n    }\n\n    getLength(){\n        return this.getPositions().length\n    }\n}\n\nclass Cheese{\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n}\n\n\nexport {\n    Snake,\n    Tail,\n    Head,\n    Cheese,\n}\n"],"sourceRoot":""}